%% This configuration is intened to benchmark antidote with protocol buffer interface.
%% The important parameters are as follows:
%% not exploit the real throughput of the system, while too high concurrency will over-stress
%% the system and trigger timeouts. The suggested number is about 20.
{concurrent, 20}.
%%
%% {mode, max|{rate, integer()}}: how frequent a thread should send request. Use 'max' for benchmarking.
%% If you are debugging, maybe {rate, N} can be useful, which means each thread sends N reqs per second.
%%
%% {operations, [{Op(), integer()}|...]}: the operation to benchmark and its proportion.
%% Current operations: read, append, append_multiple(update nine consecutive keys in a transaction),
%% read_all_write_one(read N consecutive keys and randomly pick one key to update, N is the number of 
%% antidote nodes. The assumption is that each node is assumed to have only one partition and the hash
%% fun should be integer()%N).
%% 
%% to benchmark.
%% 
%% For more information, please check : http://docs.basho.com/riak/latest/ops/building/benchmarking/

{mode, max}.

{duration, 2}.

{driver, basho_bench_driver_antidote_pb}.

%{key_generator, {dc_bias, 1, 1, 1, 1000}}.
{key_generator, {pareto_int, 2000}}.

{value_generator, {uniform_int, 100}}.

%% need to use update for orset, and append for counter
%% update performs both a read and an update
{operations, [{read_all_write_one, 1}]}.
%%{operations, [{append, 1}, {read, 10}]}.
%%{operations, [{append, 10}, {read, 10}, {append_txn, 10}, {read_txn, 10}]}.
%%{operations, [{update, 10}, {read, 10}]}.

%% the second element in the list below (e.g., "../../public/bitcask")
%% must point to % the relevant directory of a bitcask installation
{code_paths, ["../../antidote/ebin"]}.

{antidote_pb_port, 8087}.
{antidote_cookie, antidote}.

%% For transacitons
{num_reads, 10}.
{num_updates, 10}.

{antidote_mynode, ['antidote_bench@127.0.0.1', longnames]}.
%{antidote_types, [{riak_dt_gcounter, [increment]}]}.
{antidote_types, [{riak_dt_pncounter, [increment, decrement]}]}.
%%{antidote_types, [{riak_dt_orset, [add, remove]}]}.
%% Use the following parameter to set the size of the orset
{set_size, 50}.

%%{antidote_types, [{riak_dt_pncounter, [increment, decrement]}, {riak_dt_orset, [add, remove]}]}.
{antidote_pb_ips, ['127.0.0.1']}.

%% To measure staleness set put {staleness, true}
%% And set in measurements {staleness1,_} .. {stalenessN,_}, N is the number of DCs
%% There is no sanity check in the code, so make sure that the number is consistent
%% Assumption: All benchmark client running in same node connects to same DC
%% Then staleness1.csv contains localCurTime-vectorclock[DC1]
%% staleness2.csv contains localCurTime-vectorclock[DC2] etc..
{staleness, false}.
%%{measurements, [{staleness1,10}, {staleness2,10}, {staleness3,10}]}.
{num_vnodes, 64}.
